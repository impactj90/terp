// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	stderrors "errors"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ScheduleExecution schedule execution
//
// swagger:model ScheduleExecution
type ScheduleExecution struct {

	// completed at
	// Format: date-time
	CompletedAt *strfmt.DateTime `json:"completed_at,omitempty"`

	// created at
	// Format: date-time
	CreatedAt strfmt.DateTime `json:"created_at,omitempty"`

	// error message
	ErrorMessage *string `json:"error_message,omitempty"`

	// id
	// Required: true
	// Format: uuid
	ID *strfmt.UUID `json:"id"`

	// schedule id
	// Required: true
	// Format: uuid
	ScheduleID *strfmt.UUID `json:"schedule_id"`

	// started at
	// Format: date-time
	StartedAt *strfmt.DateTime `json:"started_at,omitempty"`

	// status
	// Required: true
	// Enum: ["pending","running","completed","failed","partial"]
	Status *string `json:"status"`

	// task executions
	TaskExecutions []*ScheduleTaskExecution `json:"task_executions"`

	// tasks failed
	TasksFailed int64 `json:"tasks_failed,omitempty"`

	// tasks succeeded
	TasksSucceeded int64 `json:"tasks_succeeded,omitempty"`

	// tasks total
	TasksTotal int64 `json:"tasks_total,omitempty"`

	// tenant id
	// Format: uuid
	TenantID strfmt.UUID `json:"tenant_id,omitempty"`

	// trigger type
	// Enum: ["scheduled","manual"]
	TriggerType string `json:"trigger_type,omitempty"`

	// triggered by
	// Format: uuid
	TriggeredBy *strfmt.UUID `json:"triggered_by,omitempty"`
}

// Validate validates this schedule execution
func (m *ScheduleExecution) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCompletedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScheduleID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStartedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTaskExecutions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTenantID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTriggerType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTriggeredBy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ScheduleExecution) validateCompletedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.CompletedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("completed_at", "body", "date-time", m.CompletedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ScheduleExecution) validateCreatedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.CreatedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("created_at", "body", "date-time", m.CreatedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ScheduleExecution) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	if err := validate.FormatOf("id", "body", "uuid", m.ID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ScheduleExecution) validateScheduleID(formats strfmt.Registry) error {

	if err := validate.Required("schedule_id", "body", m.ScheduleID); err != nil {
		return err
	}

	if err := validate.FormatOf("schedule_id", "body", "uuid", m.ScheduleID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *ScheduleExecution) validateStartedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.StartedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("started_at", "body", "date-time", m.StartedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

var scheduleExecutionTypeStatusPropEnum []any

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["pending","running","completed","failed","partial"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		scheduleExecutionTypeStatusPropEnum = append(scheduleExecutionTypeStatusPropEnum, v)
	}
}

const (

	// ScheduleExecutionStatusPending captures enum value "pending"
	ScheduleExecutionStatusPending string = "pending"

	// ScheduleExecutionStatusRunning captures enum value "running"
	ScheduleExecutionStatusRunning string = "running"

	// ScheduleExecutionStatusCompleted captures enum value "completed"
	ScheduleExecutionStatusCompleted string = "completed"

	// ScheduleExecutionStatusFailed captures enum value "failed"
	ScheduleExecutionStatusFailed string = "failed"

	// ScheduleExecutionStatusPartial captures enum value "partial"
	ScheduleExecutionStatusPartial string = "partial"
)

// prop value enum
func (m *ScheduleExecution) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, scheduleExecutionTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ScheduleExecution) validateStatus(formats strfmt.Registry) error {

	if err := validate.Required("status", "body", m.Status); err != nil {
		return err
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", *m.Status); err != nil {
		return err
	}

	return nil
}

func (m *ScheduleExecution) validateTaskExecutions(formats strfmt.Registry) error {
	if swag.IsZero(m.TaskExecutions) { // not required
		return nil
	}

	for i := 0; i < len(m.TaskExecutions); i++ {
		if swag.IsZero(m.TaskExecutions[i]) { // not required
			continue
		}

		if m.TaskExecutions[i] != nil {
			if err := m.TaskExecutions[i].Validate(formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("task_executions" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("task_executions" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

func (m *ScheduleExecution) validateTenantID(formats strfmt.Registry) error {
	if swag.IsZero(m.TenantID) { // not required
		return nil
	}

	if err := validate.FormatOf("tenant_id", "body", "uuid", m.TenantID.String(), formats); err != nil {
		return err
	}

	return nil
}

var scheduleExecutionTypeTriggerTypePropEnum []any

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["scheduled","manual"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		scheduleExecutionTypeTriggerTypePropEnum = append(scheduleExecutionTypeTriggerTypePropEnum, v)
	}
}

const (

	// ScheduleExecutionTriggerTypeScheduled captures enum value "scheduled"
	ScheduleExecutionTriggerTypeScheduled string = "scheduled"

	// ScheduleExecutionTriggerTypeManual captures enum value "manual"
	ScheduleExecutionTriggerTypeManual string = "manual"
)

// prop value enum
func (m *ScheduleExecution) validateTriggerTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, scheduleExecutionTypeTriggerTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ScheduleExecution) validateTriggerType(formats strfmt.Registry) error {
	if swag.IsZero(m.TriggerType) { // not required
		return nil
	}

	// value enum
	if err := m.validateTriggerTypeEnum("trigger_type", "body", m.TriggerType); err != nil {
		return err
	}

	return nil
}

func (m *ScheduleExecution) validateTriggeredBy(formats strfmt.Registry) error {
	if swag.IsZero(m.TriggeredBy) { // not required
		return nil
	}

	if err := validate.FormatOf("triggered_by", "body", "uuid", m.TriggeredBy.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this schedule execution based on the context it is used
func (m *ScheduleExecution) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateTaskExecutions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ScheduleExecution) contextValidateTaskExecutions(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.TaskExecutions); i++ {

		if m.TaskExecutions[i] != nil {

			if swag.IsZero(m.TaskExecutions[i]) { // not required
				return nil
			}

			if err := m.TaskExecutions[i].ContextValidate(ctx, formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("task_executions" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("task_executions" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ScheduleExecution) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ScheduleExecution) UnmarshalBinary(b []byte) error {
	var res ScheduleExecution
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
