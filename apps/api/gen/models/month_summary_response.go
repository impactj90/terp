// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// MonthSummaryResponse Monthly summary for an employee including time totals, flextime balance,
// absence summary, closing status, and evaluation warnings. Field names
// match the Go MonthlyValue model (e.g. total_gross_time, not gross_minutes).
//
// swagger:model MonthSummaryResponse
type MonthSummaryResponse struct {

	// Timestamp when the month was closed
	// Format: date-time
	ClosedAt *strfmt.DateTime `json:"closed_at,omitempty"`

	// User ID who closed the month
	// Format: uuid
	ClosedBy *strfmt.UUID `json:"closed_by,omitempty"`

	// Number of days with calculation errors
	DaysWithErrors int64 `json:"days_with_errors,omitempty"`

	// Employee ID
	// Format: uuid
	EmployeeID strfmt.UUID `json:"employee_id,omitempty"`

	// Flextime carryover to next month. Equal to flextime_end.
	// The next month's recalculation reads this as its flextime_start.
	//
	FlextimeCarryover int64 `json:"flextime_carryover,omitempty"`

	// Net flextime change for the month (total_overtime - total_undertime).
	// Can be negative if undertime exceeds overtime.
	//
	FlextimeChange int64 `json:"flextime_change,omitempty"`

	// Flextime balance at end of month after applying credit type rules and caps.
	// This is the value that carries over to the next month's flextime_start.
	// For credit_type "no_evaluation": flextime_start + flextime_change.
	// For credit_type "complete_carryover": flextime_start + credited (after monthly/balance caps).
	// For credit_type "after_threshold": flextime_start + credited (overtime above threshold, after caps).
	// For credit_type "no_carryover": always 0.
	//
	FlextimeEnd int64 `json:"flextime_end,omitempty"`

	// Flextime balance at start of month (carried over from previous month's flextime_end).
	// For January of a new year, this is the annual carryover value.
	//
	FlextimeStart int64 `json:"flextime_start,omitempty"`

	// Whether the month has been closed. Closed months block recalculation and new bookings.
	IsClosed bool `json:"is_closed,omitempty"`

	// Calendar month (1-12)
	// Maximum: 12
	// Minimum: 1
	Month int64 `json:"month,omitempty"`

	// Number of other absence days (special leave, etc.)
	OtherAbsenceDays int64 `json:"other_absence_days,omitempty"`

	// Timestamp when the month was last reopened
	// Format: date-time
	ReopenedAt *strfmt.DateTime `json:"reopened_at,omitempty"`

	// User ID who last reopened the month
	// Format: uuid
	ReopenedBy *strfmt.UUID `json:"reopened_by,omitempty"`

	// Number of sick days this month
	SickDays int64 `json:"sick_days,omitempty"`

	// Total break time for the month (minutes)
	TotalBreakTime int64 `json:"total_break_time,omitempty"`

	// Total gross work time for the month (minutes)
	TotalGrossTime int64 `json:"total_gross_time,omitempty"`

	// Total net work time for the month (minutes)
	TotalNetTime int64 `json:"total_net_time,omitempty"`

	// Total overtime for the month (minutes)
	TotalOvertime int64 `json:"total_overtime,omitempty"`

	// Total target work time for the month (minutes)
	TotalTargetTime int64 `json:"total_target_time,omitempty"`

	// Total undertime for the month (minutes)
	TotalUndertime int64 `json:"total_undertime,omitempty"`

	// Vacation days taken this month (supports half-day, e.g. 2.5)
	VacationTaken float64 `json:"vacation_taken,omitempty"`

	// Warning codes from monthly evaluation. Possible values:
	// - MONTHLY_CAP_REACHED: Credited flextime was capped at the monthly maximum (max_flextime_per_month)
	// - FLEXTIME_CAPPED: End balance hit the positive or negative annual cap (upper_limit_annual / lower_limit_annual)
	// - BELOW_THRESHOLD: Overtime was below the flextime threshold and was forfeited (after_threshold credit type)
	// - NO_CARRYOVER: Credit type is no_carryover, balance reset to zero
	//
	Warnings []string `json:"warnings"`

	// Number of days with recorded work time (gross_time > 0 or net_time > 0)
	WorkDays int64 `json:"work_days,omitempty"`

	// Calendar year
	Year int64 `json:"year,omitempty"`
}

// Validate validates this month summary response
func (m *MonthSummaryResponse) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateClosedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClosedBy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmployeeID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReopenedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReopenedBy(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MonthSummaryResponse) validateClosedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.ClosedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("closed_at", "body", "date-time", m.ClosedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *MonthSummaryResponse) validateClosedBy(formats strfmt.Registry) error {
	if swag.IsZero(m.ClosedBy) { // not required
		return nil
	}

	if err := validate.FormatOf("closed_by", "body", "uuid", m.ClosedBy.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *MonthSummaryResponse) validateEmployeeID(formats strfmt.Registry) error {
	if swag.IsZero(m.EmployeeID) { // not required
		return nil
	}

	if err := validate.FormatOf("employee_id", "body", "uuid", m.EmployeeID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *MonthSummaryResponse) validateMonth(formats strfmt.Registry) error {
	if swag.IsZero(m.Month) { // not required
		return nil
	}

	if err := validate.MinimumInt("month", "body", m.Month, 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("month", "body", m.Month, 12, false); err != nil {
		return err
	}

	return nil
}

func (m *MonthSummaryResponse) validateReopenedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.ReopenedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("reopened_at", "body", "date-time", m.ReopenedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *MonthSummaryResponse) validateReopenedBy(formats strfmt.Registry) error {
	if swag.IsZero(m.ReopenedBy) { // not required
		return nil
	}

	if err := validate.FormatOf("reopened_by", "body", "uuid", m.ReopenedBy.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this month summary response based on context it is used
func (m *MonthSummaryResponse) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *MonthSummaryResponse) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MonthSummaryResponse) UnmarshalBinary(b []byte) error {
	var res MonthSummaryResponse
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
