// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	stderrors "errors"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CreateTariffRequest create tariff request
//
// swagger:model CreateTariffRequest
type CreateTariffRequest struct {

	// annual target hours
	AnnualTargetHours float64 `json:"annual_target_hours,omitempty"`

	// annual vacation days
	AnnualVacationDays float64 `json:"annual_vacation_days,omitempty"`

	// code
	// Required: true
	// Max Length: 20
	// Min Length: 1
	Code *string `json:"code"`

	// credit type
	// Enum: ["no_evaluation","complete","after_threshold","no_carryover"]
	CreditType string `json:"credit_type,omitempty"`

	// For x_days rhythm: number of days in cycle
	// Maximum: 365
	// Minimum: 1
	CycleDays int64 `json:"cycle_days,omitempty"`

	// daily target hours
	DailyTargetHours float64 `json:"daily_target_hours,omitempty"`

	// For x_days: day plans per position in cycle
	DayPlans []*CreateTariffRequestDayPlansItems `json:"day_plans"`

	// description
	Description string `json:"description,omitempty"`

	// flextime threshold
	FlextimeThreshold int64 `json:"flextime_threshold,omitempty"`

	// lower limit annual
	LowerLimitAnnual int64 `json:"lower_limit_annual,omitempty"`

	// max flextime per month
	MaxFlextimePerMonth int64 `json:"max_flextime_per_month,omitempty"`

	// monthly target hours
	MonthlyTargetHours float64 `json:"monthly_target_hours,omitempty"`

	// name
	// Required: true
	// Max Length: 255
	// Min Length: 1
	Name *string `json:"name"`

	// Start date for rhythm calculation
	// Format: date
	RhythmStartDate strfmt.Date `json:"rhythm_start_date,omitempty"`

	// Time plan rhythm type (default: weekly)
	// Enum: ["weekly","rolling_weekly","x_days"]
	RhythmType string `json:"rhythm_type,omitempty"`

	// upper limit annual
	UpperLimitAnnual int64 `json:"upper_limit_annual,omitempty"`

	// vacation basis
	// Enum: ["calendar_year","entry_date"]
	VacationBasis string `json:"vacation_basis,omitempty"`

	// Links tariff to its vacation capping rule group
	// Format: uuid
	VacationCappingRuleGroupID strfmt.UUID `json:"vacation_capping_rule_group_id,omitempty"`

	// valid from
	// Format: date
	ValidFrom strfmt.Date `json:"valid_from,omitempty"`

	// valid to
	// Format: date
	ValidTo strfmt.Date `json:"valid_to,omitempty"`

	// week plan id
	// Format: uuid
	WeekPlanID strfmt.UUID `json:"week_plan_id,omitempty"`

	// For rolling_weekly: ordered list of week plan IDs
	WeekPlanIds []strfmt.UUID `json:"week_plan_ids"`

	// weekly target hours
	WeeklyTargetHours float64 `json:"weekly_target_hours,omitempty"`

	// work days per week
	// Maximum: 7
	// Minimum: 1
	WorkDaysPerWeek int64 `json:"work_days_per_week,omitempty"`
}

// Validate validates this create tariff request
func (m *CreateTariffRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreditType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCycleDays(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDayPlans(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRhythmStartDate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRhythmType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVacationBasis(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVacationCappingRuleGroupID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValidFrom(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValidTo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWeekPlanID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWeekPlanIds(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWorkDaysPerWeek(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CreateTariffRequest) validateCode(formats strfmt.Registry) error {

	if err := validate.Required("code", "body", m.Code); err != nil {
		return err
	}

	if err := validate.MinLength("code", "body", *m.Code, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("code", "body", *m.Code, 20); err != nil {
		return err
	}

	return nil
}

var createTariffRequestTypeCreditTypePropEnum []any

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["no_evaluation","complete","after_threshold","no_carryover"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		createTariffRequestTypeCreditTypePropEnum = append(createTariffRequestTypeCreditTypePropEnum, v)
	}
}

const (

	// CreateTariffRequestCreditTypeNoEvaluation captures enum value "no_evaluation"
	CreateTariffRequestCreditTypeNoEvaluation string = "no_evaluation"

	// CreateTariffRequestCreditTypeComplete captures enum value "complete"
	CreateTariffRequestCreditTypeComplete string = "complete"

	// CreateTariffRequestCreditTypeAfterThreshold captures enum value "after_threshold"
	CreateTariffRequestCreditTypeAfterThreshold string = "after_threshold"

	// CreateTariffRequestCreditTypeNoCarryover captures enum value "no_carryover"
	CreateTariffRequestCreditTypeNoCarryover string = "no_carryover"
)

// prop value enum
func (m *CreateTariffRequest) validateCreditTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, createTariffRequestTypeCreditTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CreateTariffRequest) validateCreditType(formats strfmt.Registry) error {
	if swag.IsZero(m.CreditType) { // not required
		return nil
	}

	// value enum
	if err := m.validateCreditTypeEnum("credit_type", "body", m.CreditType); err != nil {
		return err
	}

	return nil
}

func (m *CreateTariffRequest) validateCycleDays(formats strfmt.Registry) error {
	if swag.IsZero(m.CycleDays) { // not required
		return nil
	}

	if err := validate.MinimumInt("cycle_days", "body", m.CycleDays, 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("cycle_days", "body", m.CycleDays, 365, false); err != nil {
		return err
	}

	return nil
}

func (m *CreateTariffRequest) validateDayPlans(formats strfmt.Registry) error {
	if swag.IsZero(m.DayPlans) { // not required
		return nil
	}

	for i := 0; i < len(m.DayPlans); i++ {
		if swag.IsZero(m.DayPlans[i]) { // not required
			continue
		}

		if m.DayPlans[i] != nil {
			if err := m.DayPlans[i].Validate(formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("day_plans" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("day_plans" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

func (m *CreateTariffRequest) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	if err := validate.MinLength("name", "body", *m.Name, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("name", "body", *m.Name, 255); err != nil {
		return err
	}

	return nil
}

func (m *CreateTariffRequest) validateRhythmStartDate(formats strfmt.Registry) error {
	if swag.IsZero(m.RhythmStartDate) { // not required
		return nil
	}

	if err := validate.FormatOf("rhythm_start_date", "body", "date", m.RhythmStartDate.String(), formats); err != nil {
		return err
	}

	return nil
}

var createTariffRequestTypeRhythmTypePropEnum []any

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["weekly","rolling_weekly","x_days"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		createTariffRequestTypeRhythmTypePropEnum = append(createTariffRequestTypeRhythmTypePropEnum, v)
	}
}

const (

	// CreateTariffRequestRhythmTypeWeekly captures enum value "weekly"
	CreateTariffRequestRhythmTypeWeekly string = "weekly"

	// CreateTariffRequestRhythmTypeRollingWeekly captures enum value "rolling_weekly"
	CreateTariffRequestRhythmTypeRollingWeekly string = "rolling_weekly"

	// CreateTariffRequestRhythmTypeXDays captures enum value "x_days"
	CreateTariffRequestRhythmTypeXDays string = "x_days"
)

// prop value enum
func (m *CreateTariffRequest) validateRhythmTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, createTariffRequestTypeRhythmTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CreateTariffRequest) validateRhythmType(formats strfmt.Registry) error {
	if swag.IsZero(m.RhythmType) { // not required
		return nil
	}

	// value enum
	if err := m.validateRhythmTypeEnum("rhythm_type", "body", m.RhythmType); err != nil {
		return err
	}

	return nil
}

var createTariffRequestTypeVacationBasisPropEnum []any

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["calendar_year","entry_date"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		createTariffRequestTypeVacationBasisPropEnum = append(createTariffRequestTypeVacationBasisPropEnum, v)
	}
}

const (

	// CreateTariffRequestVacationBasisCalendarYear captures enum value "calendar_year"
	CreateTariffRequestVacationBasisCalendarYear string = "calendar_year"

	// CreateTariffRequestVacationBasisEntryDate captures enum value "entry_date"
	CreateTariffRequestVacationBasisEntryDate string = "entry_date"
)

// prop value enum
func (m *CreateTariffRequest) validateVacationBasisEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, createTariffRequestTypeVacationBasisPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CreateTariffRequest) validateVacationBasis(formats strfmt.Registry) error {
	if swag.IsZero(m.VacationBasis) { // not required
		return nil
	}

	// value enum
	if err := m.validateVacationBasisEnum("vacation_basis", "body", m.VacationBasis); err != nil {
		return err
	}

	return nil
}

func (m *CreateTariffRequest) validateVacationCappingRuleGroupID(formats strfmt.Registry) error {
	if swag.IsZero(m.VacationCappingRuleGroupID) { // not required
		return nil
	}

	if err := validate.FormatOf("vacation_capping_rule_group_id", "body", "uuid", m.VacationCappingRuleGroupID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CreateTariffRequest) validateValidFrom(formats strfmt.Registry) error {
	if swag.IsZero(m.ValidFrom) { // not required
		return nil
	}

	if err := validate.FormatOf("valid_from", "body", "date", m.ValidFrom.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CreateTariffRequest) validateValidTo(formats strfmt.Registry) error {
	if swag.IsZero(m.ValidTo) { // not required
		return nil
	}

	if err := validate.FormatOf("valid_to", "body", "date", m.ValidTo.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CreateTariffRequest) validateWeekPlanID(formats strfmt.Registry) error {
	if swag.IsZero(m.WeekPlanID) { // not required
		return nil
	}

	if err := validate.FormatOf("week_plan_id", "body", "uuid", m.WeekPlanID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CreateTariffRequest) validateWeekPlanIds(formats strfmt.Registry) error {
	if swag.IsZero(m.WeekPlanIds) { // not required
		return nil
	}

	for i := 0; i < len(m.WeekPlanIds); i++ {

		if err := validate.FormatOf("week_plan_ids"+"."+strconv.Itoa(i), "body", "uuid", m.WeekPlanIds[i].String(), formats); err != nil {
			return err
		}

	}

	return nil
}

func (m *CreateTariffRequest) validateWorkDaysPerWeek(formats strfmt.Registry) error {
	if swag.IsZero(m.WorkDaysPerWeek) { // not required
		return nil
	}

	if err := validate.MinimumInt("work_days_per_week", "body", m.WorkDaysPerWeek, 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("work_days_per_week", "body", m.WorkDaysPerWeek, 7, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this create tariff request based on the context it is used
func (m *CreateTariffRequest) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDayPlans(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CreateTariffRequest) contextValidateDayPlans(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.DayPlans); i++ {

		if m.DayPlans[i] != nil {

			if swag.IsZero(m.DayPlans[i]) { // not required
				return nil
			}

			if err := m.DayPlans[i].ContextValidate(ctx, formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("day_plans" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("day_plans" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *CreateTariffRequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CreateTariffRequest) UnmarshalBinary(b []byte) error {
	var res CreateTariffRequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
