// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// MonthlyValue monthly value
//
// swagger:model MonthlyValue
type MonthlyValue struct {

	// Number of absence days
	// Example: 1
	AbsenceDays float64 `json:"absence_days,omitempty"`

	// Balances per account (account_id -> minutes)
	AccountBalances map[string]int64 `json:"account_balances,omitempty"`

	// Balance (overtime - undertime)
	// Example: 420
	BalanceMinutes int64 `json:"balance_minutes,omitempty"`

	// Total break time
	// Example: 600
	BreakMinutes int64 `json:"break_minutes,omitempty"`

	// calculated at
	// Format: date-time
	CalculatedAt *strfmt.DateTime `json:"calculated_at,omitempty"`

	// closed at
	// Format: date-time
	ClosedAt *strfmt.DateTime `json:"closed_at,omitempty"`

	// closed by
	// Format: uuid
	ClosedBy *strfmt.UUID `json:"closed_by,omitempty"`

	// created at
	// Format: date-time
	CreatedAt strfmt.DateTime `json:"created_at,omitempty"`

	// employee
	Employee struct {
		EmployeeSummary
	} `json:"employee,omitempty"`

	// employee id
	// Required: true
	// Format: uuid
	EmployeeID *strfmt.UUID `json:"employee_id"`

	// Total gross work time
	// Example: 10500
	GrossMinutes int64 `json:"gross_minutes,omitempty"`

	// Number of holidays
	// Example: 0
	HolidayDays int64 `json:"holiday_days,omitempty"`

	// id
	// Required: true
	// Format: uuid
	ID *strfmt.UUID `json:"id"`

	// month
	// Example: 1
	// Required: true
	// Maximum: 12
	// Minimum: 1
	Month *int64 `json:"month"`

	// Total net work time
	// Example: 9900
	NetMinutes int64 `json:"net_minutes,omitempty"`

	// Total overtime
	// Example: 420
	OvertimeMinutes int64 `json:"overtime_minutes,omitempty"`

	// status
	// Example: calculated
	// Enum: ["open","calculated","closed","exported"]
	Status string `json:"status,omitempty"`

	// Total target work time for month
	// Example: 10080
	TargetMinutes int64 `json:"target_minutes,omitempty"`

	// tenant id
	// Required: true
	// Format: uuid
	TenantID *strfmt.UUID `json:"tenant_id"`

	// Total undertime
	// Example: 0
	UndertimeMinutes int64 `json:"undertime_minutes,omitempty"`

	// updated at
	// Format: date-time
	UpdatedAt strfmt.DateTime `json:"updated_at,omitempty"`

	// Number of days actually worked
	// Example: 20
	WorkedDays int64 `json:"worked_days,omitempty"`

	// Number of working days in month
	// Example: 21
	WorkingDays int64 `json:"working_days,omitempty"`

	// year
	// Example: 2024
	// Required: true
	Year *int64 `json:"year"`
}

// Validate validates this monthly value
func (m *MonthlyValue) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCalculatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClosedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateClosedBy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmployee(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmployeeID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMonth(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTenantID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateYear(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MonthlyValue) validateCalculatedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.CalculatedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("calculated_at", "body", "date-time", m.CalculatedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *MonthlyValue) validateClosedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.ClosedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("closed_at", "body", "date-time", m.ClosedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *MonthlyValue) validateClosedBy(formats strfmt.Registry) error {
	if swag.IsZero(m.ClosedBy) { // not required
		return nil
	}

	if err := validate.FormatOf("closed_by", "body", "uuid", m.ClosedBy.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *MonthlyValue) validateCreatedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.CreatedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("created_at", "body", "date-time", m.CreatedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *MonthlyValue) validateEmployee(formats strfmt.Registry) error {
	if swag.IsZero(m.Employee) { // not required
		return nil
	}

	return nil
}

func (m *MonthlyValue) validateEmployeeID(formats strfmt.Registry) error {

	if err := validate.Required("employee_id", "body", m.EmployeeID); err != nil {
		return err
	}

	if err := validate.FormatOf("employee_id", "body", "uuid", m.EmployeeID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *MonthlyValue) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	if err := validate.FormatOf("id", "body", "uuid", m.ID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *MonthlyValue) validateMonth(formats strfmt.Registry) error {

	if err := validate.Required("month", "body", m.Month); err != nil {
		return err
	}

	if err := validate.MinimumInt("month", "body", *m.Month, 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("month", "body", *m.Month, 12, false); err != nil {
		return err
	}

	return nil
}

var monthlyValueTypeStatusPropEnum []any

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["open","calculated","closed","exported"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		monthlyValueTypeStatusPropEnum = append(monthlyValueTypeStatusPropEnum, v)
	}
}

const (

	// MonthlyValueStatusOpen captures enum value "open"
	MonthlyValueStatusOpen string = "open"

	// MonthlyValueStatusCalculated captures enum value "calculated"
	MonthlyValueStatusCalculated string = "calculated"

	// MonthlyValueStatusClosed captures enum value "closed"
	MonthlyValueStatusClosed string = "closed"

	// MonthlyValueStatusExported captures enum value "exported"
	MonthlyValueStatusExported string = "exported"
)

// prop value enum
func (m *MonthlyValue) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, monthlyValueTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *MonthlyValue) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", m.Status); err != nil {
		return err
	}

	return nil
}

func (m *MonthlyValue) validateTenantID(formats strfmt.Registry) error {

	if err := validate.Required("tenant_id", "body", m.TenantID); err != nil {
		return err
	}

	if err := validate.FormatOf("tenant_id", "body", "uuid", m.TenantID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *MonthlyValue) validateUpdatedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.UpdatedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("updated_at", "body", "date-time", m.UpdatedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *MonthlyValue) validateYear(formats strfmt.Registry) error {

	if err := validate.Required("year", "body", m.Year); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this monthly value based on the context it is used
func (m *MonthlyValue) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateEmployee(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MonthlyValue) contextValidateEmployee(ctx context.Context, formats strfmt.Registry) error {

	return nil
}

// MarshalBinary interface implementation
func (m *MonthlyValue) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MonthlyValue) UnmarshalBinary(b []byte) error {
	var res MonthlyValue
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
