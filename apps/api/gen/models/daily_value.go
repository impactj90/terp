// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	stderrors "errors"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// DailyValue daily value
//
// swagger:model DailyValue
type DailyValue struct {

	// absence type
	AbsenceType struct {
		AbsenceTypeSummary
	} `json:"absence_type,omitempty"`

	// absence type id
	// Format: uuid
	AbsenceTypeID *strfmt.UUID `json:"absence_type_id,omitempty"`

	// Balance (overtime - undertime)
	// Example: 30
	BalanceMinutes int64 `json:"balance_minutes,omitempty"`

	// Break time in minutes
	// Example: 30
	BreakMinutes int64 `json:"break_minutes,omitempty"`

	// calculated at
	// Format: date-time
	CalculatedAt *strfmt.DateTime `json:"calculated_at,omitempty"`

	// created at
	// Format: date-time
	CreatedAt strfmt.DateTime `json:"created_at,omitempty"`

	// day plan
	DayPlan struct {
		DayPlanSummary
	} `json:"day_plan,omitempty"`

	// day plan id
	// Format: uuid
	DayPlanID *strfmt.UUID `json:"day_plan_id,omitempty"`

	// employee
	Employee struct {
		EmployeeSummary
	} `json:"employee,omitempty"`

	// employee id
	// Required: true
	// Format: uuid
	EmployeeID *strfmt.UUID `json:"employee_id"`

	// errors
	Errors []*DailyError `json:"errors"`

	// Gross work time in minutes
	// Example: 540
	GrossMinutes int64 `json:"gross_minutes,omitempty"`

	// has errors
	// Example: false
	HasErrors bool `json:"has_errors,omitempty"`

	// id
	// Required: true
	// Format: uuid
	ID *strfmt.UUID `json:"id"`

	// is absence
	// Example: false
	IsAbsence bool `json:"is_absence,omitempty"`

	// is holiday
	// Example: false
	IsHoliday bool `json:"is_holiday,omitempty"`

	// Locked after month closing
	// Example: false
	IsLocked bool `json:"is_locked,omitempty"`

	// is weekend
	// Example: false
	IsWeekend bool `json:"is_weekend,omitempty"`

	// Net work time in minutes
	// Example: 510
	NetMinutes int64 `json:"net_minutes,omitempty"`

	// Overtime in minutes
	// Example: 30
	OvertimeMinutes int64 `json:"overtime_minutes,omitempty"`

	// status
	// Example: calculated
	// Required: true
	// Enum: ["pending","calculated","error","approved"]
	Status *string `json:"status"`

	// Target work time in minutes
	// Example: 480
	TargetMinutes int64 `json:"target_minutes,omitempty"`

	// tenant id
	// Required: true
	// Format: uuid
	TenantID *strfmt.UUID `json:"tenant_id"`

	// Undertime in minutes
	// Example: 0
	UndertimeMinutes int64 `json:"undertime_minutes,omitempty"`

	// updated at
	// Format: date-time
	UpdatedAt strfmt.DateTime `json:"updated_at,omitempty"`

	// value date
	// Example: 2024-01-15
	// Required: true
	// Format: date
	ValueDate *strfmt.Date `json:"value_date"`
}

// Validate validates this daily value
func (m *DailyValue) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAbsenceType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAbsenceTypeID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCalculatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDayPlan(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDayPlanID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmployee(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmployeeID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateErrors(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTenantID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValueDate(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DailyValue) validateAbsenceType(formats strfmt.Registry) error {
	if swag.IsZero(m.AbsenceType) { // not required
		return nil
	}

	return nil
}

func (m *DailyValue) validateAbsenceTypeID(formats strfmt.Registry) error {
	if swag.IsZero(m.AbsenceTypeID) { // not required
		return nil
	}

	if err := validate.FormatOf("absence_type_id", "body", "uuid", m.AbsenceTypeID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *DailyValue) validateCalculatedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.CalculatedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("calculated_at", "body", "date-time", m.CalculatedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *DailyValue) validateCreatedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.CreatedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("created_at", "body", "date-time", m.CreatedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *DailyValue) validateDayPlan(formats strfmt.Registry) error {
	if swag.IsZero(m.DayPlan) { // not required
		return nil
	}

	return nil
}

func (m *DailyValue) validateDayPlanID(formats strfmt.Registry) error {
	if swag.IsZero(m.DayPlanID) { // not required
		return nil
	}

	if err := validate.FormatOf("day_plan_id", "body", "uuid", m.DayPlanID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *DailyValue) validateEmployee(formats strfmt.Registry) error {
	if swag.IsZero(m.Employee) { // not required
		return nil
	}

	return nil
}

func (m *DailyValue) validateEmployeeID(formats strfmt.Registry) error {

	if err := validate.Required("employee_id", "body", m.EmployeeID); err != nil {
		return err
	}

	if err := validate.FormatOf("employee_id", "body", "uuid", m.EmployeeID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *DailyValue) validateErrors(formats strfmt.Registry) error {
	if swag.IsZero(m.Errors) { // not required
		return nil
	}

	for i := 0; i < len(m.Errors); i++ {
		if swag.IsZero(m.Errors[i]) { // not required
			continue
		}

		if m.Errors[i] != nil {
			if err := m.Errors[i].Validate(formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("errors" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("errors" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

func (m *DailyValue) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	if err := validate.FormatOf("id", "body", "uuid", m.ID.String(), formats); err != nil {
		return err
	}

	return nil
}

var dailyValueTypeStatusPropEnum []any

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["pending","calculated","error","approved"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dailyValueTypeStatusPropEnum = append(dailyValueTypeStatusPropEnum, v)
	}
}

const (

	// DailyValueStatusPending captures enum value "pending"
	DailyValueStatusPending string = "pending"

	// DailyValueStatusCalculated captures enum value "calculated"
	DailyValueStatusCalculated string = "calculated"

	// DailyValueStatusError captures enum value "error"
	DailyValueStatusError string = "error"

	// DailyValueStatusApproved captures enum value "approved"
	DailyValueStatusApproved string = "approved"
)

// prop value enum
func (m *DailyValue) validateStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, dailyValueTypeStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *DailyValue) validateStatus(formats strfmt.Registry) error {

	if err := validate.Required("status", "body", m.Status); err != nil {
		return err
	}

	// value enum
	if err := m.validateStatusEnum("status", "body", *m.Status); err != nil {
		return err
	}

	return nil
}

func (m *DailyValue) validateTenantID(formats strfmt.Registry) error {

	if err := validate.Required("tenant_id", "body", m.TenantID); err != nil {
		return err
	}

	if err := validate.FormatOf("tenant_id", "body", "uuid", m.TenantID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *DailyValue) validateUpdatedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.UpdatedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("updated_at", "body", "date-time", m.UpdatedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *DailyValue) validateValueDate(formats strfmt.Registry) error {

	if err := validate.Required("value_date", "body", m.ValueDate); err != nil {
		return err
	}

	if err := validate.FormatOf("value_date", "body", "date", m.ValueDate.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this daily value based on the context it is used
func (m *DailyValue) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAbsenceType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDayPlan(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEmployee(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateErrors(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DailyValue) contextValidateAbsenceType(ctx context.Context, formats strfmt.Registry) error {

	return nil
}

func (m *DailyValue) contextValidateDayPlan(ctx context.Context, formats strfmt.Registry) error {

	return nil
}

func (m *DailyValue) contextValidateEmployee(ctx context.Context, formats strfmt.Registry) error {

	return nil
}

func (m *DailyValue) contextValidateErrors(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Errors); i++ {

		if m.Errors[i] != nil {

			if swag.IsZero(m.Errors[i]) { // not required
				return nil
			}

			if err := m.Errors[i].ContextValidate(ctx, formats); err != nil {
				ve := new(errors.Validation)
				if stderrors.As(err, &ve) {
					return ve.ValidateName("errors" + "." + strconv.Itoa(i))
				}
				ce := new(errors.CompositeError)
				if stderrors.As(err, &ce) {
					return ce.ValidateName("errors" + "." + strconv.Itoa(i))
				}

				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *DailyValue) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DailyValue) UnmarshalBinary(b []byte) error {
	var res DailyValue
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
