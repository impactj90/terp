// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// DailyError daily error
//
// swagger:model DailyError
type DailyError struct {

	// Related booking if applicable
	// Format: uuid
	BookingID *strfmt.UUID `json:"booking_id,omitempty"`

	// created at
	// Format: date-time
	CreatedAt strfmt.DateTime `json:"created_at,omitempty"`

	// daily value id
	// Required: true
	// Format: uuid
	DailyValueID *strfmt.UUID `json:"daily_value_id"`

	// error type
	// Example: missing_booking
	// Required: true
	// Enum: ["missing_booking","unpaired_booking","overlapping_bookings","core_time_violation","exceeds_max_hours","below_min_hours","break_violation","invalid_sequence"]
	ErrorType *string `json:"error_type"`

	// id
	// Required: true
	// Format: uuid
	ID *strfmt.UUID `json:"id"`

	// message
	// Example: Missing clock-out booking
	// Required: true
	Message *string `json:"message"`

	// severity
	// Example: error
	// Enum: ["warning","error"]
	Severity string `json:"severity,omitempty"`
}

// Validate validates this daily error
func (m *DailyError) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBookingID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDailyValueID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateErrorType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMessage(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSeverity(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DailyError) validateBookingID(formats strfmt.Registry) error {
	if swag.IsZero(m.BookingID) { // not required
		return nil
	}

	if err := validate.FormatOf("booking_id", "body", "uuid", m.BookingID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *DailyError) validateCreatedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.CreatedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("created_at", "body", "date-time", m.CreatedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *DailyError) validateDailyValueID(formats strfmt.Registry) error {

	if err := validate.Required("daily_value_id", "body", m.DailyValueID); err != nil {
		return err
	}

	if err := validate.FormatOf("daily_value_id", "body", "uuid", m.DailyValueID.String(), formats); err != nil {
		return err
	}

	return nil
}

var dailyErrorTypeErrorTypePropEnum []any

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["missing_booking","unpaired_booking","overlapping_bookings","core_time_violation","exceeds_max_hours","below_min_hours","break_violation","invalid_sequence"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dailyErrorTypeErrorTypePropEnum = append(dailyErrorTypeErrorTypePropEnum, v)
	}
}

const (

	// DailyErrorErrorTypeMissingBooking captures enum value "missing_booking"
	DailyErrorErrorTypeMissingBooking string = "missing_booking"

	// DailyErrorErrorTypeUnpairedBooking captures enum value "unpaired_booking"
	DailyErrorErrorTypeUnpairedBooking string = "unpaired_booking"

	// DailyErrorErrorTypeOverlappingBookings captures enum value "overlapping_bookings"
	DailyErrorErrorTypeOverlappingBookings string = "overlapping_bookings"

	// DailyErrorErrorTypeCoreTimeViolation captures enum value "core_time_violation"
	DailyErrorErrorTypeCoreTimeViolation string = "core_time_violation"

	// DailyErrorErrorTypeExceedsMaxHours captures enum value "exceeds_max_hours"
	DailyErrorErrorTypeExceedsMaxHours string = "exceeds_max_hours"

	// DailyErrorErrorTypeBelowMinHours captures enum value "below_min_hours"
	DailyErrorErrorTypeBelowMinHours string = "below_min_hours"

	// DailyErrorErrorTypeBreakViolation captures enum value "break_violation"
	DailyErrorErrorTypeBreakViolation string = "break_violation"

	// DailyErrorErrorTypeInvalidSequence captures enum value "invalid_sequence"
	DailyErrorErrorTypeInvalidSequence string = "invalid_sequence"
)

// prop value enum
func (m *DailyError) validateErrorTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, dailyErrorTypeErrorTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *DailyError) validateErrorType(formats strfmt.Registry) error {

	if err := validate.Required("error_type", "body", m.ErrorType); err != nil {
		return err
	}

	// value enum
	if err := m.validateErrorTypeEnum("error_type", "body", *m.ErrorType); err != nil {
		return err
	}

	return nil
}

func (m *DailyError) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	if err := validate.FormatOf("id", "body", "uuid", m.ID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *DailyError) validateMessage(formats strfmt.Registry) error {

	if err := validate.Required("message", "body", m.Message); err != nil {
		return err
	}

	return nil
}

var dailyErrorTypeSeverityPropEnum []any

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["warning","error"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		dailyErrorTypeSeverityPropEnum = append(dailyErrorTypeSeverityPropEnum, v)
	}
}

const (

	// DailyErrorSeverityWarning captures enum value "warning"
	DailyErrorSeverityWarning string = "warning"

	// DailyErrorSeverityError captures enum value "error"
	DailyErrorSeverityError string = "error"
)

// prop value enum
func (m *DailyError) validateSeverityEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, dailyErrorTypeSeverityPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *DailyError) validateSeverity(formats strfmt.Registry) error {
	if swag.IsZero(m.Severity) { // not required
		return nil
	}

	// value enum
	if err := m.validateSeverityEnum("severity", "body", m.Severity); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this daily error based on context it is used
func (m *DailyError) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *DailyError) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DailyError) UnmarshalBinary(b []byte) error {
	var res DailyError
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
